#!/usr/bin/python3

# CREDENTIALS:
#   autor: Andrew Astakhov <https://github.com/sthv> aa@contextmachine.ru
# ABOUT:
#   A small but nice utility for loading environment variables into the current shell process at runtime.
# USAGE:
# To get help:
#  $ ./load_dotenv -h/--help

# Import from file:
# First, make the script executable, for example as follows:
#
#  $ chmod +x load_dotenv
#
#  Now you should be use this program with `eval` directive, like:
#
#  $ eval $(./load_dotenv <file1> <file2> ...)
#  $ eval $(./load_dotenv myenv1.env myenv2.env)
#
#  If no argument is passed, it looks for a '.env' file in the current directory.
#                eval $(./load_dotenv)
#  Literally the following will happen (python): `dotenv.find_dotenv('.env', usecwd=True)`
#

import sys
import subprocess as sp
import warnings

esc = '\033[0m'
DARK_MAGENTA = '\033[0;35m'
NC='\x1b[0m' # No Color
BLACK='\x1b[0;30m'
GRAY='\033[0;105m'
RED='\x1b[0;31m'
LIGHT_RED='\x1b[1;31m'
GREEN='\x1b[1;32m'
LIGHT_GREEN='\x1b[1;32m'
BROWN='\x1b[0;33m'
YELLOW='\x1b[1;33m'
BLUE='\x1b[0;34m'
LIGHT_BLUE='\x1b[1;34m'
PURPLE='\x1b[0;35m'
LIGHT_PURPLE='\x1b[1;35m'
CYAN='\x1b[0;36m'
LIGHT_CYAN='\x1b[1;36m'
LIGHT_GRAY='\x1b[0;37m'
DARK_GREEN="\033[38;5;35m"
WHITE='\x1b[1;37m'

description = "Load env to your shell from .env like file, or files."
_usage = "Help:\n\t\t./load_dotenv -h/--help\n\n\tYou should be use this program with `eval` directive, " \
         "like:\n\n\t\teval $(./load_dotenv <file1> <file2> ...)\n\t\teval $(./load_dotenv myenv1.env myenv2.env)" \
         "\n\n\tIf no argument is passed, it looks for a '.env' file in the current directory. \n\t" \
         "\n\t\teval $(./load_dotenv)\n\n\tLiterally the following will happen (python): `dotenv.find_dotenv('.env', " \
         "usecwd=True)`\n\n".replace(
         'eval', '{LIGHT_CYAN}eval{esc}', -1).replace(
         './load_dotenv', '{CYAN}./load_dotenv{esc}', -1).replace(
         'Help', '{YELLOW}Help{esc}').replace(
         'find_dotenv', '{CYAN}find_dotenv{esc}').replace(
          "'.env'",'{LIGHT_GREEN}".env"{esc}').replace(
          "usecwd",'{BROWN}usecwd{esc}').replace(
          "True",'{LIGHT_BLUE}True{esc}')


usage = eval(f"f\"\"\"{_usage}\"\"\"")


class MyLiteral:
    def __class_getitem__(cls, parameters):
        return cls(*parameters)

    def __init__(self, *parameters):
        self._parameters = parameters

    def __contains__(self, other):
        ans = False
        for i in self._parameters:
            if i in other:
                ans = True
                break
            else:
                continue
        return ans

    def __repr__(self):
        return f"{self.__class__.__name__}[{', '.join(self._parameters)}]"


def main(args):
    try:
        import dotenv

    except ImportError as err:

        proc = sp.Popen(
                ["/usr/bin/python3", "-m", "pip", "install", "--upgrade", "--no-warn-script-location", "python-dotenv"])
        proc.wait(timeout=600)
        import dotenv
    except Exception as err:
        raise err

    # print(args)
    for arg in args:

        if arg:

            for k, v in dotenv.dotenv_values(dotenv.find_dotenv(filename=arg, usecwd=True)).items():
                print(f"export {k}={v}")

                # sys.stdin.write(f"export {k}={v}")

    return 0


if __name__ == "__main__":
    if sys.argv[1:] in MyLiteral['-h', '--help']:
        print(f"{description}\n\nUSAGE:\n\t{usage}\n")
        warnings.simplefilter("ignore")
    else:
        main(sys.argv[1:])
